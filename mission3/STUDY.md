# 해당 프로젝트를 통해서 배운점


## 1. 쿼리?

솔직히 쿼리가 무엇인지 자세하게 알긴 힘들었다.. 그래서 좀더 원초적인 의미가 무엇인지를 알아야했어서 단어를 구글링 하기 시작했다. query란 라틴어 quaerere 라는 단어에서 유래되었으며, 의미는 묻다, 질의하다, 질의, 문의 라는 뜻을 가진 영어이라는 것을 알게되었다. 서버는 클라이언트의 요청을 받아서 (query) 해결한다는 것을 체감하게 되었다.. 쿼리는 유저들과 소통하는 기본적인 요청 단위이며, 이를 통해서 우리는 유저들과 소통을 한다.

### 왜쓰는가?

쿼리를 왜쓰는지 궁금해졌다.. 일단 난 쿼리가 세상에 나오지 않았다라는 가정을 두고 생각을 해보았다. 일단 우리가 아는 데이터는 빙산의 일각이다라는 사실을 숙지해야한다.... 수많은 데이터를 컴퓨터의 cpu나 메모리가 이것들을 받아서 해결을 해야하며, 개발자들은 해당 과정을 통해서 실수를 하는 경우가 많아질것이다. 
해당 문제점들을 방지하기위해서, 쿼리를 쓴다... 쿼리를 통해서 필터링된 요청된 데이터를 서버에 보내면 컴퓨터는 cpu는 효율적으로 일하게 되고, 개발자들의 실수들은 줄어든다.. 

### 쿼리의 종류와 형태

Sql에서 쿼리의 종류는 크게 네가지로 나눠진다

요청받은 데이터를 서버로 부터 가지고 오거나, 요청받은 데이터의 결과값을 클라이언트 보내주거나, 삭제하거나, 데이터를 생성하는 역할을 한다.

우리는 ORM기반인 prisma를 통해서 위의 작업들 한다. (그래서 findMany나 create할때 객체를 파라미터로 받는다.)

* select 
    요청받은 데이터를 가지고 오는 역할을 맡는다(findMany, findUnique).
    ```sql
    SELECT * FROM users WHERE name = 'Juno'; 
    ```
    * findMany 

        prisma를 통해서 많은 데이터를 찾아주는 함수이다. 조건문이나 조건 연산자를 이용한 데이터를 어떻게 가지고올까 라는 궁금함이 생겼다...물론 유효성 검사를 통해서 가지고오는 것과 똑같아보인다.... 명확히 알아하는 건 유효성검사는 형식이나 데이터 존재 유무를 보지, 필터링은 하지않는다. 퀴리내에서 if나 or 와같은 키워드는 쓸수 없다... 쿼리를 쓰기전에 필터링을 하거나, 쿼리내에서 삼항연산자를 쓰면 된다.

        ```js
        const results = await prisma.model.findMany({
            where: {
                OR: [ ... ],
                AND: [ ... ],
                NOT: [ ... ]
            }
        });
        ```  

        ```js
        const results = await prisma.model.findMany({
            where:{
                ...(ageFilter ? { age: { gte: 18 } } : {}),
            }
        })
        ```
    * findUnique 
        
        prisma를 통해서 특정한 데이터를 찾아주는 함수

* insert
    데이터를 서버에 추가하는 역(create)

* update
    수정된 데이터를 서버에 보내는 역(patch)

* delete
    데이터를 삭제하는 역


## 2. validation

내가 처음 썼던 방식은 class validator 였음. 알고리즘문제 가지치기에 익숙해져있어서 편해서였던거 같다. 그러고 모든 유효성 검사를 zod로 바꿔서 코드를 재작성. 내가 validator에서 헷갈렸던 거는 유효성 검사의 범위였다. 형식의 올바름, 값이 존재하는가를 검사하는 게 유효성검사. 절대 범위룰 검사하지않는다.

## 3. 파일들을 역할별로 나누기

난 처음에 디렉토리로 먼저 역할을 나눴다 product, comment, 자유게시판, 이미지 업로드 으로 대분류 하였고, 세부적으로 product에는 product API, comment API 에는 comment api, 자유게시판 API로 나눴다. 하지만 여기 이렇게 접근을 하니 완성했을때 코드가 상당히 복잡해지는 것을 느끼기 시작했다. 구글링밒 챗지피티를 통해서 각각의 디렉토리 내에서 파일들을 좀더 역할별로 세분화해서 접근하는 방법을 배웠다. 인덱스 라우터 -> 프로덕트 라우터/ comment 라우터 / 자유게시판 라우터 이렇게 경로를 먼저 설정을 하기위해서 각각의 디렉토리 내에 router 파일들을 만들어서 경로들을 설정을해두었고, 경로를 통해서 요청된 데이터들을 처리하는 함수들을 컨트롤러 파일, 유효성 검사를 위한 validator 파일과 스키마, 서비스(공통된 컨트롤러 함수를 위한) 파일들을 만들었다.이렇게 하니 코드가 상당히 깔끔해졌다. 그러니 가독성또한 엄청 올라갔다.

## where의 용도

난 처음에 해당 키워드의 용도는 주로 어디에 저장할것인가를 나타내는 키워드로 접근을 하였다. 그래서 당연히 findMany에서는 쓸일이 없을것이라고 오만한 생각을 했고, 혼쭐 났다.... findUnique나 삭제 메소드, 수정메소드에서는 함수를 실행할 부분을 나타내는것은 맞다. 하지만 조건부 검색을 요청 하는 API에서도 where은 쓰인다. 요청된 키워드가 존재할시에 해당 필드의 속성값을 가지고 오는 역할이다.

## read only 
난 처음에 get으로 데이터를 받아와서 해당정보를 수정하려고 했는데 read 오류가 나왔다. 클래스를 쓰지않았던 난 이게 무슨 말인지 몰랐었다. get을 하는 순간 해당 객체는 오르지 읽을 수 만 있다. 수정하려면 set 함수를 써야 가능하다.


## relation 

상위 스키마에서는 어떤형태로 데이터를 저장할지 하위 스키마는 데이터가 어떤형태로 저장해야 하는 지의 틀이다 . 솔직히 해당 미션을 할때 조금 많이 헷갈렸었는데 난 이부분을 삼단논법으로 이해하기 시작했다. 1. 모든 제품은 태그들을 가지고 있으며, 모든 태그들은 제품들 안에 있다, 2. 